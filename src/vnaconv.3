.\" e t
.\"
.\" Vector Network Analyzer Library
.\" Copyright Â© 2020-2023 D Scott Guthridge <scott_guthridge@rompromity.net>
.\"
.\" This program is free software: you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published
.\" by the Free Software Foundation, either version 3 of the License, or
.\" (at your option) any later version.
.\"
.\" This program is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
.\" General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this program.  If not, see <http://www.gnu.org/licenses/>.
.\"
.TH VNACONV 3 "2023-09-03" GNU
.nh
.SH NAME
vnaconv_atob, vnaconv_atog, vnaconv_atoh, vnaconv_atos, vnaconv_atot, vnaconv_atou, vnaconv_atoy, vnaconv_atoz, vnaconv_atozi, vnaconv_btoa, vnaconv_btog, vnaconv_btoh, vnaconv_btos, vnaconv_btot, vnaconv_btou, vnaconv_btoy, vnaconv_btoz, vnaconv_btozi, vnaconv_gtoa, vnaconv_gtob, vnaconv_gtoh, vnaconv_gtos, vnaconv_gtot, vnaconv_gtou, vnaconv_gtoy, vnaconv_gtoz, vnaconv_gtozi, vnaconv_htoa, vnaconv_htob, vnaconv_htog, vnaconv_htos, vnaconv_htot, vnaconv_htou, vnaconv_htoy, vnaconv_htoz, vnaconv_htozi, vnaconv_stoa, vnaconv_stob, vnaconv_stog, vnaconv_stoh, vnaconv_stot, vnaconv_stou, vnaconv_stoy, vnaconv_stoyn, vnaconv_stoz, vnaconv_stozi, vnaconv_stozin, vnaconv_stozn, vnaconv_ttoa, vnaconv_ttob, vnaconv_ttog, vnaconv_ttoh, vnaconv_ttos, vnaconv_ttou, vnaconv_ttoy, vnaconv_ttoz, vnaconv_ttozi, vnaconv_utoa, vnaconv_utob, vnaconv_utog, vnaconv_utoh, vnaconv_utos, vnaconv_utot, vnaconv_utoy, vnaconv_utoz, vnaconv_utozi, vnaconv_ytoa, vnaconv_ytob, vnaconv_ytog, vnaconv_ytoh, vnaconv_ytos, vnaconv_ytosn, vnaconv_ytot, vnaconv_ytou, vnaconv_ytoz, vnaconv_ytozi, vnaconv_ytozin, vnaconv_ytozn, vnaconv_ztoa, vnaconv_ztob, vnaconv_ztog, vnaconv_ztoh, vnaconv_ztos, vnaconv_ztosn, vnaconv_ztot, vnaconv_ztou, vnaconv_ztoy, vnaconv_ztoyn, vnaconv_ztozi, vnaconv_ztozin \- convert 2-port and N-port network parameters
.\"
.SH SYNOPSIS
.SS "Include and Link"
.B #include <vnaconv.h>
.PP
Link with \fI-lvna\fP \fI-lm\fP.
.SS "Two-Port Matrix Conversions"
.PP
.BI "void vnaconv_stot(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_stou(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_stoz(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_stoy(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_stoh(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_stog(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_stoa(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_stob(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttos(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ttou(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ttoz(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttoy(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttoh(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttog(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttoa(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttob(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utos(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_utot(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_utoz(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utoy(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utoh(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utog(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utoa(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utob(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ztos(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ztot(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ztou(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ztoy(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ztoh(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ztog(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ztoa(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ztob(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ytos(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ytot(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ytou(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ytoz(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ytoh(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ytog(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ytoa(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ytob(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_htos(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_htot(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_htou(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_htoz(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_htoy(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_htog(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_htoa(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_htob(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_gtos(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_gtot(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_gtou(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_gtoz(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_gtoy(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_gtoh(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_gtoa(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_gtob(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_atos(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_atot(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_atou(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_atoz(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_atoy(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_atoh(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_atog(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_atob(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_btos(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_btot(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_btou(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_btoz(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_btoy(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_btoh(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_btog(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_btoa(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2]);"
.if n .RE
.\"
.SS "2-Port Matrix to Input Impedance"
.PP
.BI "void vnaconv_stozi(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttozi(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utozi(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ztozi(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ytozi(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_htozi(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_gtozi(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_atozi(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_btozi(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.\"
.SS "N-Port Matrix Conversions"
.PP
.BI "void vnaconv_stozn(const double complex *" s ", double complex *" z ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.PP
.BI "void vnaconv_stoyn(const double complex *" s ", double complex *" y ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.PP
.BI "void vnaconv_ztosn(const double complex *" z ", double complex *" s ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.PP
.BI "void vnaconv_ztoyn(const double complex *" z ", double complex *" y ,
.BI "int " n ");"
.PP
.BI "void vnaconv_ytosn(const double complex *" y ", double complex *" s ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.PP
.BI "void vnaconv_ytozn(const double complex *" y ", double complex *" z ,
.BI "int " n ");"
.\"
.SS "N-Port Matrix To Input Impedance"
.PP
.BI "void vnaconv_stozin(const double complex *" s ", double complex *" zi ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.PP
.BI "void vnaconv_ztozin(const double complex *" z ", double complex *" zi ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.PP
.BI "void vnaconv_ytozin(const double complex *" y ", double complex *" zi ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.\"
.SH DESCRIPTION
These functions convert between various mathematical representations
of electrical n-port networks.
Representations include scattering (s-parameters), scattering-transfer
(t-parameters), inverse scattering-transfer (u-parameters), impedance
(z-parameters), admittance (y-parameters), hybrid (h-parameters),
inverse hybrid (g-parameters), \s-2ABCD\s+2 (a-parameters) and inverse
\s-2ABCD\s+2 (b-parameters).
.PP
While s-parameters, z-parameters and y-parameters are defined for any
number of ports, t-parameters, u-paramters, h-parameters, g-parameters,
a-parameters and b-parameters are defined for two-port networks only.
The library contains one set of functions for two-port networks and
another set of functions for n-port networks \- the later all have names
ending in \fBn\fP.
For example, \fBvnaconv_stoy\fP() is the function to convert from
s-parameters to y-parameters for two-port, while \fBvnaconv_stoyn\fP()
is the equivalent function for n-ports.
The two-port functions take matrices of type double complex [2][2] while
the n-port functions take the address of the first element of an \fIn\fP
x \fIn\fP complex matrix (appearing in memory in C row-major order).
In both cases, the input and output matrices can refer to the same
memory, i.e. you can pass the same matrix as input and output
to do an in-place conversion.
.PP
The \fIz0\fP parameter, common to both cases, is a pointer to a vector
of system impedances, i.e. the impedance seen by the network looking out
of each of its ports.
.PP
Two-port example:
.RS +4n
.nf
double complex s[2][2];
double complex z[2][2];
static double complex z0[2] = { 50.0, 50.0 };

vnaconv_stoz(s, z, z0);
.fi
.RE
.PP
N-port example:
.RS +4n
.nf
double complex s[3][3];
double complex z[3][3];
static double complex z0[3] = { 50.0, 75.0, 110.0 };

vnaconv_stozn(&s[0][0], &z[0][0], z0, 3);
.fi
.RE
.\"
.PP
In order to give a more detailed description of the various parameter
matrices, we must first give a few definitions:
.sp
.RS +4n
a1 and a2 are the incident voltages into ports 1 and 2,
.br
b1 and b2 are the reflected voltages out of ports 1 and 2,
.br
v1 and v2 are the voltages at ports 1 and 2,
.br
i1 and i2 are the currents into ports 1 and 2, and
.br
Z1 and Z2 are the system impedances the device sees looking out of
its ports.
.PP
Note that for a1, a2, b1 and b2, we're using \(lqvoltage\(rq loosely.
More precisely, these values are defined as root power in units of
Watt^(1/2).
In most cases, this distinction isn't important because the scale
factor divides out.
.RE
.sp
The relationships between
.ie t \{\
.EQ
{ A sub i }, { B sub i }, { V sub i }, { I sub i }
.EN
.\}
.el \{\
a1, a2, b1, b2, v1, v2, i1 and i2
.\}
are:
.sp
.RS +4n
.ie t \{\
.EQ
matrix{
    lcol{
        { a sub i = { 1 over 2 } { K sub i } ( { V sub i } + { I sub i } { Z sub i } ) }
        above
        { b sub i = { 1 over 2 } { K sub i } ( { V sub i } - { I sub i } { Z sub i sup * } ) }
    }
    lcol{
        { V sub i } = { { { a sub i } { Z sub i sup * } + { b sub i } { Z sub i } } over { { K sub i } re({ Z sub i }) } }
        above
        { I sub i } = { { { a sub i } - { b sub i } } over { { K sub i } re({ Z sub i }) } }
    }
}
.EN
.sp
where
.EQ
{ K sub i } = { { 1 } over { sqrt{ |{ re({ Z sub i }) }| } } },
.EN
and * is the conjugation operator.
.\}
.el \{\
.TS
tab(;);
l l.
a1 = 1/2 K1 (v1 + Z1  i1); v1 = (Z1* a1 + Z1 b1) / (K1 real(Z1))
b1 = 1/2 K1 (v1 - Z1* i1); i1 = (a1 - b1)        / (K1 real(Z1))
a2 = 1/2 K2 (v2 + Z2  i2); v2 = (Z2* a2 + Z2 b2) / (K2 real(Z2))
b2 = 1/2 K2 (v2 - Z2* i2); i2 = (a2 - b2)        / (K2 real(Z2))
.TE
.sp
.nf
where: K1 = 1 / sqrt(abs(real(Z1)))
       K2 = 1 / sqrt(abs(real(Z2)))
       and * is the conjugate operator
.fi
.\}
.RE
.sp
We can now show the relationships for each representation of network
parameters.  The \fBs\fP (scattering) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { b sub 1 } above { b sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { s sub 11 } above { s sub 21 } }
               ccol{ { s sub 12 } above { s sub 22 } } } right ] ~
left [ matrix{ ccol{ { a sub 1 } above { a sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ b1 ]   [ s11 s12 ] [ a1 ]
[    ] = [         ] [    ]
[ b2 ]   [ s21 s22 ] [ a2 ]
.fi
.\}
.RE
.PP
The \fBt\fP (scattering-transfer) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { b sub 1 } above { a sub 1 } } } right ] ~=~
left [ matrix{ ccol{ { t sub 11 } above { t sub 21 } }
               ccol{ { t sub 12 } above { t sub 22 } } } right ] ~
left [ matrix{ ccol{ { a sub 2 } above { b sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ b1 ]   [ t11 t12 ] [ a2 ]
[    ] = [         ] [    ]
[ a1 ]   [ t21 t22 ] [ b2 ]
.fi
.\}
.sp
The \fBt\fP parameters for a cascade of two-port networks is the
left-to-right matrix product of the \fBt\fP parameters of each successive
stage.
.RE
.sp
.PP
The \fBu\fP (inverse scattering-transfer) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { a sub 2 } above { b sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { u sub 11 } above { u sub 21 } }
               ccol{ { u sub 12 } above { u sub 22 } } } right ] ~
left [ matrix{ ccol{ { b sub 1 } above { a sub 1 } } } right ]
.EN
.\}
.el \{\
.nf
[ a2 ]   [ u11 u12 ] [ b1 ]
[    ] = [         ] [    ]
[ b2 ]   [ u21 u22 ] [ a1 ]
.fi
.\}
.sp
The \fBu\fP parameters for a cascade of two-port networks is the
right-to-left matrix product of the \fBu\fP parameters of each successive
stage.
.RE
.sp
.PP
The \fBz\fP (impedance) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { V sub 1 } above { V sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { z sub 11 } above { z sub 21 } }
               ccol{ { z sub 12 } above { z sub 22 } } } right ] ~
left [ matrix{ ccol{ { I sub 1 } above { I sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ v1 ]   [ z11 z12 ] [ i1 ]
[    ] = [         ] [    ]
[ v2 ]   [ z21 z22 ] [ i2 ]
.fi
.\}
.RE
.sp
.PP
The \fBy\fP (admittance) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { I sub 1 } above { I sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { y sub 11 } above { y sub 21 } }
               ccol{ { y sub 12 } above { y sub 22 } } } right ] ~
left [ matrix{ ccol{ { V sub 1 } above { V sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ i1 ]   [ y11 y12 ] [ v1 ]
[    ] = [         ] [    ]
[ i2 ]   [ y21 y22 ] [ v2 ]
.fi
.\}
.RE
.sp
.PP
The \fBh\fP (hybrid) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { V sub 1 } above { I sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { h sub 11 } above { h sub 21 } }
               ccol{ { h sub 12 } above { h sub 22 } } } right ] ~
left [ matrix{ ccol{ { I sub 1 } above { V sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ v1 ]   [ h11 h12 ] [ i1 ]
[    ] = [         ] [    ]
[ i2 ]   [ h21 h22 ] [ v2 ]
.fi
.\}
.RE
.sp
.PP
The \fBg\fP (inverse hybrid) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { I sub 1 } above { V sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { g sub 11 } above { g sub 21 } }
               ccol{ { g sub 12 } above { g sub 22 } } } right ] ~
left [ matrix{ ccol{ { V sub 1 } above { I sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ i1 ]   [ g11 g12 ] [ v1 ]
[    ] = [         ] [    ]
[ v2 ]   [ g21 g22 ] [ i2 ]
.fi
.\}
.RE
.sp
.PP
The \fBa\fP (ABCD) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { V sub 1 } above { I sub 1 } } } right ] ~=~
left [ matrix{ ccol{ { a sub 11 } above { a sub 21 } }
               ccol{ { a sub 12 } above { a sub 22 } } } right ] ~
left [ matrix{ ccol{ { V sub 2 } above -{ I sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ v1 ]   [ a11 a12 ] [  v2 ]
[    ] = [         ] [     ]
[ i1 ]   [ a21 a22 ] [ -i2 ]
.fi
.\}
.sp
The \fBa\fP parameters for a cascade of two-port networks is the
left-to-right matrix product of the \fBa\fP parameters of each successive
stage.  Don't confuse the \fBa\fP matrix with the a1 and a2 voltages
above.
.RE
.sp
.PP
The \fBb\fP (inverse ABCD) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { V sub 2 } above -{ I sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { b sub 11 } above { b sub 21 } }
               ccol{ { b sub 12 } above { b sub 22 } } } right ] ~
left [ matrix{ ccol{ { V sub 1 } above { I sub 1 } } } right ]
.EN
.\}
.el \{\
.nf
[  v2 ]   [ b11 b12 ] [ v1 ]
[     ] = [         ] [    ]
[ -i2 ]   [ b21 b22 ] [ i1 ]
.fi
.\}
.sp
The \fBb\fP parameters for a cascade of two-port networks is the
right-to-left matrix product of the \fBb\fP parameters of each successive
stage.  Don't confuse the \fBb\fP matrix with the b1 and b2 voltages
above.
.RE
.\"
.PP
In addition to the functions that convert between parameter forms,
there are also functions that calculate the input impedances looking
into each port of the network when all other ports are terminated at
the system impedances.
For example, \fBvnaconv_stozi\fP() finds the input impedances from a
2x2 s-parameter matrix, while \fBvnaconv_ztozin\fP() finds the input
impedances from an \fIn\fP by \fIn\fP z-parameter matrix.
The \fIzi\fP and \fIz0\fP vectors must have length \fIn\fP.
.\"
.SH "RETURN VALUE"
All functions return void.  The result matrix may contain inf or nan
values if the conversion is nondeterministic.
.\"
.\" .SH ERRORS
.\" None.
.\" .SH BUGS
.\" None known.
.\"
.SH NOTES
The declarations showing parameters with array types, e.g. \fBdouble
complex\fP \fIs\fP[2][2], would be more honestly written as having type
pointer to an element of the array.  In this particular example the
actual type is \fBdouble complex\fP (\fI*s\fP)[2] \- pointer to array of
two double complex values.  If you have a variable of this type and you
add 1 to it, it advances to the next row.  We've chosen, however, to use
the equivalent in C (but somewhat misleading) parameter array notation to
more clearly document what the user is expected to pass to the function.
In the include file, they're written in the pointer to element form.
.\"
.SH EXAMPLES
.nf
.ft CW
#include <complex.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <vnaconv.h>

/* system impedances */
#define Z1      75.0
#define Z2      50.0

/* resistor values for impedance matching L pad */
#define R1      (sqrt(Z1) * sqrt(Z1 - Z2))
#define R2      (sqrt(Z1) * Z2 / sqrt(Z1 - Z2))

/* system impedance vector */
static const double complex z0[] = { Z1, Z2 };

int main(int argc, char **argv)
{
    const double complex z[2][2] = { /* Z-parameters of the L pad */
        { R1+R2, R2 },
        { R2,    R2 }
    };
    double complex s[2][2];
    double complex zi[2];

    /*
     * Convert to S-parameters.
     */
    vnaconv_ztos(z, s, z0);
    (void)printf("s-parameters:\\n");
    (void)printf("  %7.4f%+7.4fi    %7.4f%+7.4fi\\n",
        creal(s[0][0]), cimag(s[0][0]), creal(s[0][1]), cimag(s[0][1]));
    (void)printf("  %7.4f%+7.4fi    %7.4f%+7.4fi\\n",
        creal(s[1][0]), cimag(s[1][0]), creal(s[1][1]), cimag(s[1][1]));
    (void)printf("\\n");

    /*
     * Convert to input impedance at each port.
     */
    vnaconv_stozi(s, zi, z0);
    (void)printf("input-impedances:\\n");
    (void)printf("  %7.4f%+7.4fi    %7.4f%+7.4fi\\n",
        creal(zi[0]), cimag(zi[0]), creal(zi[1]), cimag(zi[1]));
    (void)printf("\\n");

    exit(0);
}
.ft R
.fi
.\"
.SH "SEE ALSO"
.BR vnacal "(3), " vnacal_new "(3), " vnadata "(3), " vnaerr "(3),"
.BR vnacal_parameter "(3)"
