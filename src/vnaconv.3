.\" e t
.\"
.\" Vector Network Analyzer Library
.\" Copyright Â© 2020-2024 D Scott Guthridge <scott_guthridge@rompromity.net>
.\"
.\" This program is free software: you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published
.\" by the Free Software Foundation, either version 3 of the License, or
.\" (at your option) any later version.
.\"
.\" This program is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
.\" General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this program.  If not, see <http://www.gnu.org/licenses/>.
.\"
.TH VNACONV 3 "2024-10-18" GNU
.nh
.SH NAME
vnaconv_atob, vnaconv_atog, vnaconv_atoh, vnaconv_atos, vnaconv_atot, vnaconv_atou, vnaconv_atoy, vnaconv_atoz, vnaconv_atozi, vnaconv_btoa, vnaconv_btog, vnaconv_btoh, vnaconv_btos, vnaconv_btot, vnaconv_btou, vnaconv_btoy, vnaconv_btoz, vnaconv_btozi, vnaconv_gtoa, vnaconv_gtob, vnaconv_gtoh, vnaconv_gtos, vnaconv_gtot, vnaconv_gtou, vnaconv_gtoy, vnaconv_gtoz, vnaconv_gtozi, vnaconv_htoa, vnaconv_htob, vnaconv_htog, vnaconv_htos, vnaconv_htot, vnaconv_htou, vnaconv_htoy, vnaconv_htoz, vnaconv_htozi, vnaconv_stoa, vnaconv_stob, vnaconv_stog, vnaconv_stoh, vnaconv_stosr, vnaconv_stosrn, vnaconv_stot, vnaconv_stotr, vnaconv_stou, vnaconv_stour, vnaconv_stoy, vnaconv_stoyn, vnaconv_stoz, vnaconv_stozi, vnaconv_stozin, vnaconv_stozn, vnaconv_ttoa, vnaconv_ttob, vnaconv_ttog, vnaconv_ttoh, vnaconv_ttos, vnaconv_ttosr, vnaconv_ttotr, vnaconv_ttou, vnaconv_ttour, vnaconv_ttoy, vnaconv_ttoz, vnaconv_ttozi, vnaconv_utoa, vnaconv_utob, vnaconv_utog, vnaconv_utoh, vnaconv_utos, vnaconv_utosr, vnaconv_utot, vnaconv_utotr, vnaconv_utour, vnaconv_utoy, vnaconv_utoz, vnaconv_utozi, vnaconv_ytoa, vnaconv_ytob, vnaconv_ytog, vnaconv_ytoh, vnaconv_ytos, vnaconv_ytosn, vnaconv_ytot, vnaconv_ytou, vnaconv_ytoz, vnaconv_ytozi, vnaconv_ytozin, vnaconv_ytozn, vnaconv_ztoa, vnaconv_ztob, vnaconv_ztog, vnaconv_ztoh, vnaconv_ztos, vnaconv_ztosn, vnaconv_ztot, vnaconv_ztou, vnaconv_ztoy, vnaconv_ztoyn, vnaconv_ztozi, vnaconv_ztozin \- convert 2-port and N-port network parameters
.\"
.SH SYNOPSIS
.SS "Include and Link"
.B #include <vnaconv.h>
.PP
Link with \fI-lvna\fP \fI-lm\fP.
.SS "Two-Port Conversions"
.PP
.BI "void vnaconv_stot(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_stou(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_stoz(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_stoy(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_stoh(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_stog(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_stoa(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_stob(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttos(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ttou(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ttoz(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttoy(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttoh(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttog(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttoa(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttob(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utos(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_utot(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_utoz(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utoy(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utoh(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utog(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utoa(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utob(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ztos(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ztot(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ztou(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ztoy(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ztoh(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ztog(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ztoa(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ztob(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ytos(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ytot(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ytou(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ytoz(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ytoh(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ytog(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ytoa(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_ytob(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_htos(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_htot(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_htou(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_htoz(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_htoy(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_htog(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_htoa(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_htob(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_gtos(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_gtot(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_gtou(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_gtoz(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_gtoy(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_gtoh(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_gtoa(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_gtob(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_atos(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_atot(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_atou(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_atoz(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_atoy(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_atoh(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_atog(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_atob(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " b "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_btos(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_btot(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_btou(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_btoz(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " z "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_btoy(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " y "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_btoh(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " h "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_btog(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " g "[2][2]);"
.if n .RE
.PP
.BI "void vnaconv_btoa(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " a "[2][2]);"
.if n .RE
.\"
.SS "2-Port Matrix to Input Impedance"
.PP
.BI "void vnaconv_stozi(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ttozi(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_utozi(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ztozi(const double complex " z "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_ytozi(const double complex " y "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_htozi(const double complex " h "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_gtozi(const double complex " g "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_atozi(const double complex " a "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.PP
.BI "void vnaconv_btozi(const double complex " b "[2][2],"
.if n .RS +4n
.BI "double complex " zi "[2],"
.if !n .RS +4n
.BI "const double complex " z0 "[2]);"
.RE
.\"
.SS "N-Port Conversions"
.PP
.BI "void vnaconv_stozn(const double complex *" s ", double complex *" z ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.PP
.BI "void vnaconv_stoyn(const double complex *" s ", double complex *" y ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.PP
.BI "void vnaconv_ztosn(const double complex *" z ", double complex *" s ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.PP
.BI "void vnaconv_ztoyn(const double complex *" z ", double complex *" y ,
.BI "int " n ");"
.PP
.BI "void vnaconv_ytosn(const double complex *" y ", double complex *" s ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.PP
.BI "void vnaconv_ytozn(const double complex *" y ", double complex *" z ,
.BI "int " n ");"
.\"
.SS "N-Port Matrix To Input Impedance"
.PP
.BI "void vnaconv_stozin(const double complex *" s ", double complex *" zi ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.PP
.BI "void vnaconv_ztozin(const double complex *" z ", double complex *" zi ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.PP
.BI "void vnaconv_ytozin(const double complex *" y ", double complex *" zi ,
.RS +4n
.BI "const double complex *" z0 ", int " n ");"
.RE
.SS "Two-port Renormalizing Conversions"
.PP
.BI "void vnaconv_stosr(const double complex " s_in "[2][2],"
.if n .RS +4n
.BI "double complex " s_out "[2][2],"
.if !n .RS +4n
.BI "const double complex " z1 "[2],"
.if n .br
.BI "const double complex " z2 "[2]);"
.RE
.PP
.BI "void vnaconv_stotr(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z1 "[2],"
.if n .br
.BI "const double complex " z2 "[2]);"
.RE
.PP
.BI "void vnaconv_stour(const double complex " s "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z1 "[2],"
.if n .br
.BI "const double complex " z2 "[2]);"
.RE
.PP
.BI "void vnaconv_ttosr(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z1 "[2],"
.if n .br
.BI "const double complex " z2 "[2]);"
.RE
.PP
.BI "void vnaconv_ttotr(const double complex " t_in "[2][2],"
.if n .RS +4n
.BI "double complex " t_out "[2][2],"
.if !n .RS +4n
.BI "const double complex " z1 "[2],"
.if n .br
.BI "const double complex " z2 "[2]);"
.RE
.PP
.BI "void vnaconv_ttour(const double complex " t "[2][2],"
.if n .RS +4n
.BI "double complex " u "[2][2],"
.if !n .RS +4n
.BI "const double complex " z1 "[2],"
.if n .br
.BI "const double complex " z2 "[2]);"
.RE
.PP
.BI "void vnaconv_utosr(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " s "[2][2],"
.if !n .RS +4n
.BI "const double complex " z1 "[2],"
.if n .br
.BI "const double complex " z2 "[2]);"
.RE
.PP
.BI "void vnaconv_utotr(const double complex " u "[2][2],"
.if n .RS +4n
.BI "double complex " t "[2][2],"
.if !n .RS +4n
.BI "const double complex " z1 "[2],"
.if n .br
.BI "const double complex " z2 "[2]);"
.RE
.PP
.BI "void vnaconv_utour(const double complex " u_in "[2][2],"
.if n .RS +4n
.BI "double complex " u_out "[2][2],"
.if !n .RS +4n
.BI "const double complex " z1 "[2],"
.if n .br
.BI "const double complex " z2 "[2]);"
.SS "N-port Renormalizing Conversions"
.PP
.BI "void vnaconv_stosrn(const double complex *" s_in ","
.if n .RS +4n
.BI "double complex *" s_out ","
.if !n .RS +4n
.BI "const double complex *" z1 ","
.if n .br
.BI "const double complex *" z2 ");"
.RE
.\"
.SH DESCRIPTION
These functions convert between various mathematical representations of
electrical n-port networks.
Representations include s (scattering), t (scattering-transfer), u
(inverse scattering-transfer), z (impedance), y (admittance), h (hybrid),
g (inverse hybrid), a (\s-2ABCD\s+2) and b (inverse \s-2ABCD\s+2)
parameters.
While s, z and y parameters are defined for any number of ports, t, u,
h, g, a and b parameters are defined for two-port networks only.
.PP
The s, t and u representations are always associated with a vector of
reference impedances, \fIz0\fP, indicating the defined impedances seen
by the network when looking out of each of its ports.
The impedance vector must be given when converting from one of these to
any of the other parameter types, and vice versa.
The renormalizing conversions, e.g. \fBvnaconv_stosr\fP() convert s, t
and u parameters from an initial set of reference impedances, \fIz1\fP,
to a new set of reference impedances, \fIz2\fP.
.PP
The library contains one set of functions for two-port networks and
another set of functions for n-port networks \- the later all have names
ending in \fBn\fP.
For example, \fBvnaconv_stoy\fP() is the function to convert from
s-parameters to y-parameters for two-port, while \fBvnaconv_stoyn\fP()
is the equivalent function for n-ports.
The two-port functions take matrices of type double complex [2][2] while
the n-port functions take the address of the first element of an \fIn\fP
x \fIn\fP complex matrix (appearing in memory in C row-major order).
In both cases, the input and output matrices can refer to the same
memory, i.e. you can pass the same matrix as input and output
to do an in-place conversion.
.PP
Two-port example:
.RS +4n
.nf
double complex s[2][2];
double complex z[2][2];
static double complex z0[2] = { 50.0, 50.0 };

vnaconv_stoz(s, z, z0);
.fi
.RE
.PP
N-port example:
.RS +4n
.nf
double complex s[3][3];
double complex z[3][3];
static double complex z0[3] = { 50.0, 75.0, 110.0 };

vnaconv_stozn(&s[0][0], &z[0][0], z0, 3);
.fi
.RE
.\"
.SS "Theory of Operation"
.PP
The functions in this library follow the Kurokawa power wave model,
where scattering parameters represent ratios of root power.
In order to delve into the mathematical definitions of each parameter
type, we need to start with few definitions:
.sp
.RS +4n
a1 and a2 are incident root power into ports 1 and 2,
.br
b1 and b2 are reflected root power out of ports 1 and 2,
.br
v1 and v2 are the voltages at ports 1 and 2,
.br
i1 and i2 are the currents into ports 1 and 2, and
.br
Z1 and Z2 are the defined reference impedances the device sees looking
out of its ports.
.PP
The a1, a2, b1 and b2 are defined as root power in units of Watt^(1/2).
In most cases, the precise unit in which these parameters are defined
isn't important because the scale factor divides out.
.RE
.sp
The relationships between
.ie t \{\
.EQ
{ A sub i }, { B sub i }, { V sub i }, { I sub i }
.EN
.\}
.el \{\
a1, a2, b1, b2, v1, v2, i1 and i2
.\}
are:
.sp
.RS +4n
.ie t \{\
.EQ
matrix{
    lcol{
        { a sub i = { 1 over 2 } { K sub i } ( { V sub i } + { I sub i } { Z sub i } ) }
        above
        { b sub i = { 1 over 2 } { K sub i } ( { V sub i } - { I sub i } { Z sub i sup * } ) }
    }
    lcol{
        { V sub i } = { { { a sub i } { Z sub i sup * } + { b sub i } { Z sub i } } over { { K sub i } re({ Z sub i }) } }
        above
        { I sub i } = { { { a sub i } - { b sub i } } over { { K sub i } re({ Z sub i }) } }
    }
}
.EN
.sp
where
.EQ
{ K sub i } = { { 1 } over { sqrt{ |{ re({ Z sub i }) }| } } },
.EN
and * is the conjugation operator.
.\}
.el \{\
.TS
tab(;);
l l.
a1 = 1/2 K1 (v1 + Z1  i1); v1 = (Z1* a1 + Z1 b1) / (K1 real(Z1))
b1 = 1/2 K1 (v1 - Z1* i1); i1 = (a1 - b1)        / (K1 real(Z1))
a2 = 1/2 K2 (v2 + Z2  i2); v2 = (Z2* a2 + Z2 b2) / (K2 real(Z2))
b2 = 1/2 K2 (v2 - Z2* i2); i2 = (a2 - b2)        / (K2 real(Z2))
.TE
.sp
.nf
where: K1 = 1 / sqrt(abs(real(Z1)))
       K2 = 1 / sqrt(abs(real(Z2)))
       and * is the conjugate operator
.fi
.\}
.RE
.sp
We can now show the relationships for each representation of network
parameters.  The \fBs\fP (scattering) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { b sub 1 } above { b sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { s sub 11 } above { s sub 21 } }
               ccol{ { s sub 12 } above { s sub 22 } } } right ] ~
left [ matrix{ ccol{ { a sub 1 } above { a sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ b1 ]   [ s11 s12 ] [ a1 ]
[    ] = [         ] [    ]
[ b2 ]   [ s21 s22 ] [ a2 ]
.fi
.\}
.RE
.PP
The \fBt\fP (scattering-transfer) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { b sub 1 } above { a sub 1 } } } right ] ~=~
left [ matrix{ ccol{ { t sub 11 } above { t sub 21 } }
               ccol{ { t sub 12 } above { t sub 22 } } } right ] ~
left [ matrix{ ccol{ { a sub 2 } above { b sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ b1 ]   [ t11 t12 ] [ a2 ]
[    ] = [         ] [    ]
[ a1 ]   [ t21 t22 ] [ b2 ]
.fi
.\}
.sp
The \fBt\fP parameters for a cascade of two-port networks is the
left-to-right matrix product of the \fBt\fP parameters of each successive
stage.
.RE
.sp
.PP
The \fBu\fP (inverse scattering-transfer) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { a sub 2 } above { b sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { u sub 11 } above { u sub 21 } }
               ccol{ { u sub 12 } above { u sub 22 } } } right ] ~
left [ matrix{ ccol{ { b sub 1 } above { a sub 1 } } } right ]
.EN
.\}
.el \{\
.nf
[ a2 ]   [ u11 u12 ] [ b1 ]
[    ] = [         ] [    ]
[ b2 ]   [ u21 u22 ] [ a1 ]
.fi
.\}
.sp
The \fBu\fP parameters for a cascade of two-port networks is the
right-to-left matrix product of the \fBu\fP parameters of each successive
stage.
.RE
.sp
.PP
The \fBz\fP (impedance) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { V sub 1 } above { V sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { z sub 11 } above { z sub 21 } }
               ccol{ { z sub 12 } above { z sub 22 } } } right ] ~
left [ matrix{ ccol{ { I sub 1 } above { I sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ v1 ]   [ z11 z12 ] [ i1 ]
[    ] = [         ] [    ]
[ v2 ]   [ z21 z22 ] [ i2 ]
.fi
.\}
.RE
.sp
.PP
The \fBy\fP (admittance) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { I sub 1 } above { I sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { y sub 11 } above { y sub 21 } }
               ccol{ { y sub 12 } above { y sub 22 } } } right ] ~
left [ matrix{ ccol{ { V sub 1 } above { V sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ i1 ]   [ y11 y12 ] [ v1 ]
[    ] = [         ] [    ]
[ i2 ]   [ y21 y22 ] [ v2 ]
.fi
.\}
.RE
.sp
.PP
The \fBh\fP (hybrid) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { V sub 1 } above { I sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { h sub 11 } above { h sub 21 } }
               ccol{ { h sub 12 } above { h sub 22 } } } right ] ~
left [ matrix{ ccol{ { I sub 1 } above { V sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ v1 ]   [ h11 h12 ] [ i1 ]
[    ] = [         ] [    ]
[ i2 ]   [ h21 h22 ] [ v2 ]
.fi
.\}
.RE
.sp
.PP
The \fBg\fP (inverse hybrid) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { I sub 1 } above { V sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { g sub 11 } above { g sub 21 } }
               ccol{ { g sub 12 } above { g sub 22 } } } right ] ~
left [ matrix{ ccol{ { V sub 1 } above { I sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ i1 ]   [ g11 g12 ] [ v1 ]
[    ] = [         ] [    ]
[ v2 ]   [ g21 g22 ] [ i2 ]
.fi
.\}
.RE
.sp
.PP
The \fBa\fP (ABCD) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { V sub 1 } above { I sub 1 } } } right ] ~=~
left [ matrix{ ccol{ { a sub 11 } above { a sub 21 } }
               ccol{ { a sub 12 } above { a sub 22 } } } right ] ~
left [ matrix{ ccol{ { V sub 2 } above -{ I sub 2 } } } right ]
.EN
.\}
.el \{\
.nf
[ v1 ]   [ a11 a12 ] [  v2 ]
[    ] = [         ] [     ]
[ i1 ]   [ a21 a22 ] [ -i2 ]
.fi
.\}
.sp
The \fBa\fP parameters for a cascade of two-port networks is the
left-to-right matrix product of the \fBa\fP parameters of each successive
stage.  Don't confuse the \fBa\fP matrix with the a1 and a2 voltages
above.
.RE
.sp
.PP
The \fBb\fP (inverse ABCD) parameters satisfy:
.sp
.RS +4n
.ie t \{\
.EQ
left [ matrix{ ccol{ { V sub 2 } above -{ I sub 2 } } } right ] ~=~
left [ matrix{ ccol{ { b sub 11 } above { b sub 21 } }
               ccol{ { b sub 12 } above { b sub 22 } } } right ] ~
left [ matrix{ ccol{ { V sub 1 } above { I sub 1 } } } right ]
.EN
.\}
.el \{\
.nf
[  v2 ]   [ b11 b12 ] [ v1 ]
[     ] = [         ] [    ]
[ -i2 ]   [ b21 b22 ] [ i1 ]
.fi
.\}
.sp
The \fBb\fP parameters for a cascade of two-port networks is the
right-to-left matrix product of the \fBb\fP parameters of each successive
stage.  Don't confuse the \fBb\fP matrix with the b1 and b2 voltages
above.
.RE
.\"
.PP
In addition to the functions that convert between parameter forms,
there are also functions that calculate the input impedances looking
into each port of the network when all other ports are terminated at
the reference impedances.
For example, \fBvnaconv_stozi\fP() finds the input impedances from a
2x2 s-parameter matrix, while \fBvnaconv_ztozin\fP() finds the input
impedances from an \fIn\fP by \fIn\fP z-parameter matrix.
The \fIzi\fP and \fIz0\fP vectors must have length \fIn\fP.
.\"
.SH "RETURN VALUE"
All functions return void.  The result matrix may contain inf or nan
values if the conversion is nondeterministic.
.\"
.\" .SH ERRORS
.\" None.
.\" .SH BUGS
.\" None known.
.\"
.SH NOTES
The declarations showing parameters with array types, e.g. \fBdouble
complex\fP \fIs\fP[2][2], would be more honestly written as having type
pointer to an element of the array.  In this particular example the
actual type is \fBdouble complex\fP (\fI*s\fP)[2] \- pointer to array of
two double complex values.  If you have a variable of this type and you
add 1 to it, it advances to the next row.  We've chosen, however, to use
the equivalent in C (but somewhat misleading) parameter array notation to
more clearly document what the user is expected to pass to the function.
In the include file, they're written in the pointer to element form.
.\"
.SH EXAMPLES
.nf
.ft CW
#include <complex.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <vnaconv.h>

/* reference impedances */
#define Z1      75.0
#define Z2      50.0

/* resistor values for impedance matching L pad */
#define R1      (sqrt(Z1) * sqrt(Z1 - Z2))
#define R2      (sqrt(Z1) * Z2 / sqrt(Z1 - Z2))

/* reference impedance vector */
static const double complex z0[] = { Z1, Z2 };

int main(int argc, char **argv)
{
    const double complex z[2][2] = { /* Z-parameters of the L pad */
        { R1+R2, R2 },
        { R2,    R2 }
    };
    double complex s[2][2];
    double complex zi[2];

    /*
     * Convert to S-parameters.
     */
    vnaconv_ztos(z, s, z0);
    (void)printf("s-parameters:\\n");
    (void)printf("  %7.4f%+7.4fi    %7.4f%+7.4fi\\n",
        creal(s[0][0]), cimag(s[0][0]), creal(s[0][1]), cimag(s[0][1]));
    (void)printf("  %7.4f%+7.4fi    %7.4f%+7.4fi\\n",
        creal(s[1][0]), cimag(s[1][0]), creal(s[1][1]), cimag(s[1][1]));
    (void)printf("\\n");

    /*
     * Convert to input impedance at each port.
     */
    vnaconv_stozi(s, zi, z0);
    (void)printf("input-impedances:\\n");
    (void)printf("  %7.4f%+7.4fi    %7.4f%+7.4fi\\n",
        creal(zi[0]), cimag(zi[0]), creal(zi[1]), cimag(zi[1]));
    (void)printf("\\n");

    exit(0);
}
.ft R
.fi
.\"
.SH "SEE ALSO"
.BR vnacal "(3), " vnacal_new "(3), " vnadata "(3), " vnaerr "(3),"
.BR vnacal_parameter "(3)"
