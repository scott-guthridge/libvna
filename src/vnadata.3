.\"
.\" Vector Network Analyzer Library
.\" Copyright Â© 2020, 2021 D Scott Guthridge <scott_guthridge@rompromity.net>
.\"
.\" This program is free software: you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published
.\" by the Free Software Foundation, either version 3 of the License, or
.\" (at your option) any later version.
.\"
.\" This program is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
.\" General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this program.  If not, see <http://www.gnu.org/licenses/>.
.\"
.TH VNADATA 3 "JULY 2017" GNU
.nh
.SH NAME
vnadata_alloc, vnadata_init, vnadata_alloc_and_init, vnadata_resize, vnadata_get_rows, vnadata_get_columns, vnadata_get_frequencies, vnadata_get_type, vnadata_set_type, vnadata_get_typename, vnadata_free, vnadata_get_frequency, vnadata_set_frequency, vnadata_get_frequency_vector, vnadata_set_frequency_vector, vnadata_add_frequency, vnadata_get_cell, vnadata_set_cell, vnadata_get_matrix, vnadata_set_matrix, vnadata_get_to_vector, vnadata_set_to_vector, vnadata_get_z0, vnadata_set_z0, vnadata_get_z0_vector, vnadata_set_z0_vector, vnadata_set_all_z0, vnadata_get_fz0, vnadata_set_fz0, vnadata_get_fz0_vector, vnadata_set_fz0_vector, vnadata_convert \- Network Parameter Data
.\"
.SH SYNOPSIS
.B #include <vnadata.h>
.SS "Allocation and Initialization"
.PP
.BI "vnadata_t *vnadata_alloc()"
.\"
.PP
.BI "int vnadata_init(vnadata_t *" vdp ", int " frequencies ", int " rows ,
.ie n \{\
.in +4n
.\}
.BI "int " columns ,
.el \{\
.in +4n
.\}
.BI "vnadata_parameter_type_t " type );
.in -4n
.\"
.PP
.BI "vnadata_t *vnadata_alloc_and_init(int " frequencies ,
.ie n \{\
.in +4n
.\}
.BI "int " rows ", int " columns ,
.el \{\
.in +4n
.\}
.BI "vnadata_parameter_type_t " type );
.in -4n
.\"
.PP
.BI "int vnadata_resize(vnadata_t *" vdp ", int " frequencies ", int " rows ,
.ie n \{\
.in +4n
.\}
.BI "int " columns ,
.el \{\
.in +4n
.\}
.BI "vnadata_parameter_type_t " type );
.in -4n
.\"
.PP
.BI "int vnadata_get_frequencies(const vnadata_t *" vdp );
.\"
.PP
.BI "int vnadata_get_rows(const vnadata_t *" vdp );
.\"
.PP
.BI "int vnadata_get_columns(const vnadata_t *" vdp );
.\"
.PP
.BI "vnadata_parameter_type_t vnadata_get_type(const vnadata_t *" vdp );
.\"
.PP
.BI "int vnadata_set_type(const vnadata_t *" vdp ,
.ie n \{\
.in +4n
.\}
.BI "vnadata_parameter_type_t " type );
.if n \{\
.in -4n
.\}
.\"
.PP
.BI "const char *vnadata_get_typename(vnadata_parameter_type_t " type );
.\"
.PP
.BI "void vnadata_free(vnadata_t *" vdp );
.\"
.SS "The Frequency Vector"
.PP
.BI "double vnadata_get_frequency(const vnadata_t *" vdp ", int " findex );
.\"
.PP
.BI "int vnadata_set_frequency(vnadata_t *" vdp ", int " findex ,
.if n \{\
.in +4n
.\}
.BI "double " frequency );
.if n \{\
.in -4n
.\}
.\"
.PP
.BI "const double *vnadata_get_frequency_vector(const vnadata_t *" vdp );
.\"
.PP
.BI "int vnadata_set_frequency_vector(vnadata_t *" vdp ,
.if n \{\
.in +4n
.\}
.BI "const double *" frequency_vector );
.if n \{\
.in -4n
.\}
.\"
.PP
.BI "int vnadata_add_frequency(vnadata_t *" vdp ", double " frequency );
.\"
.SS "Data Elements"
.PP
.BI "complex vnadata_get_cell(vnadata_t *" vdp ", int " findex ", int " row ,
.if n \{\
.in +4n
.\}
.BI "int " column );
.if n \{\
.in -4n
.\}
.\"
.PP
.BI "int vnadata_set_cell(vnadata_t *" vdp ", int " findex ", int " row ,
.if n \{\
.in +4n
.\}
.BI "int " column ", double complex " value );
.if n \{\
.in -4n
.\}
.\"
.PP
.BI "const double complex *vnadata_get_matrix(const vnadata_t *" vdp ,
.if n \{\
.in +4n
.\}
.BI "int " findex );
.if n \{\
.in -4n
.\}
.\"
.PP
.BI "int vnadata_set_matrix(vnadata_t *" vdp ", int " findex ,
.if n \{\
.in +4n
.\}
.BI "const double complex *" matrix );
.if n \{\
.in -4n
.\}
.\"
.PP
.BI "int vnadata_get_to_vector(const vnadata_t *" vdp ", int " row ,
.BI "int " column ,
.if n \{\
.in +4n
.\}
.BI "double complex *" vector );
.if n \{\
.in -4n
.\}
.\"
.PP
.BI "int vnadata_set_from_vector(vnadata_t *" vdp ", int " row ,
.BI "int " column ,
.if n \{\
.in +4n
.\}
.BI "const double complex *" vector );
.if n \{\
.in -4n
.\}
.\"
.SS "Ordinary System Impedances"
.PP
.BI "double complex vnadata_get_z0(const vnadata_t *" vdp ", int " port );
.\"
.PP
.BI "int vnadata_set_z0(vnadata_t *" vdp ", int " port ", double complex " z0 );
.\"
.PP
.BI "const double complex *vnadata_get_z0_vector(const vnadata_t *" vdp );
.\"
.PP
.BI "int vnadata_set_z0_vector(vnadata_t *" vdp ,
.if n \{\
.in +4n
.\}
.BI "const double complex *" z0_vector );
.if n \{\
.in -4n
.\}
.\"
.PP
.BI "int vnadata_set_all_z0(vnadata_t *" vdp ", double complex " z0 );
.\"
.SS "Frequency-Dependent System Impedances"
.PP
.BI "int vnadata_get_fz0(const vnadata_t *" vdp ", int " findex ", int " port );
.\"
.PP
.BI "int vnadata_set_fz0(vnadata_t *" vdp ", int " findex ", int " port ,
.if n \{\
.in +4n
.\}
.BI "double complex " z0 );
.if n \{\
.in -4n
.\}
.\"
.PP
.BI "const double complex *vnadata_get_fz0_vector(const vnadata_t *" vdp ,
.if n \{\
.in +4n
.\}
.BI "int " findex );
.if n \{\
.in -4n
.\}
.\"
.PP
.BI "int vnadata_set_fz0_vector(vnadata_t *" vdp ", int " findex ,
.if n \{\
.in +4n
.\}
.BI "const double complex *" z0_vector );
.if n \{\
.in -4n
.\}
.\"
.SS "Parameter Conversion"
.PP
.BI "int vnadata_convert(const vnadata_t *" vdp_in ", vnadata_t *" vdp_out ,
.in +4n
.BI "vnadata_parameter_type_t " newtype );
.in -4n
.\"
.PP
Link with \fI-lvnaconv\fP \fI-lm\fP.
.\"
.SH DESCRIPTION
These functions store and manage electrical network parameter data.
Internally, the data are stored as a vector of matrices, one per frequency.
The matrix may contain any of s (scattering), t (scattering transfer),
z (impedance), y (admittance), h (hybrid), g (inverse-hybrid), a (ABCD),
b (inverse ABCD) or zin (input impedance) parameters.
.PP
The \fBvnadata_alloc\fP() function allocates an empty \fBvnadata_t\fP
structure of type VPT_UNDEF.
This is useful for creating the empty output container for other functions
such as \fBvnadata_convert\fP(), or \fBvnacal_input_apply\fP(3).
.PP
The \fBvnadata_init\fP() function sets the dimensions and type of the
\fBvnadata_t\fP structure, initializes all frequency and data cells to
zero and all z0 entries to the default of 50 ohms.
The \fItype\fP argument must be one of: VPT_UNDEF, VPT_S, VPT_Z, VPT_Y,
VPT_T, VPT_H, VPT_G, VPT_A, VPT_B, or VPT_ZIN, and the dimensions must
be consistent with the type.
.PP
The \fBvnadata_alloc_and_init\fP() function is a combination
of \fBvnadata_alloc\fP() and \fBvnadata_init\fP().
.PP
The \fBvnadata_get_frequencies\fP(), \fBvnadata_get_rows\fP() and
\fBvnadata_get_columns\fP(), and \fBvnadata_get_type\fP() functions query
the dimensions and type of the structure, and \fBvna_get_typename\fP()
returns \fItype\fP as a string.
The \fBvnadata_set_type\fP() function changes the parameter type without
doing conversions.
The \fItype\fP parameter must be consistent with the matrix dimensions.
.PP
The \fBvnadata_resize\fP() function changes the dimensions and/or type
of the matrix.
Note that this function is value-preserving when changing the number of
frequencies, the number of rows or the type, but it doesn't reform the
matrix when changing the number of columns.
Changing the type doesn't convert existing data.
.PP
The \fBvnadata_free\fP() function frees the structure and its contents.
.PP
The \fBvnadata_get_frequency\fP() and \fBvnadata_set_frequency\fP()
functions get and set the frequency at index \fIfindex\fP, respectively.
The \fBvnadata_get_frequency_vector\fP() and
\fBvnadata_set_frequency_vector\fP() functions get and set the whole
frequency vector.
The length of \fIfrequency_vector\fP must match \fIfrequencies\fP.
.PP
The \fBvnadata_add_frequency\fP() function adds a new frequency entry
at the end, filling the associated data elements with initial values.
This function is useful, for example, when parsing a Touchstone V1 file,
where you don't know the number of frequencies up-front.
.PP
The \fBvnadata_get_cell\fP() and \fBvnadata_set_cell\fP() functions
get and set indivdual data elements.
The \fBvnadata_get_matrix\fP() and \fBvnadata_set_matrix\fP() functions
get and set the full parameter data matrix for the given frequency.
The \fImatrix\fP parameter is a pointer to a vector of double complex
containing the flattened matrix elements in row-major order.
.PP
The \fBvnadata_set_from_vector\fP() and \fBvnadata_get_to_vector\fP()
functions copy a vector of data values, one entry per frequency, into
a \fBvnadata_t\fP matrix cell, and vice versa.
The \fIvector\fP argument must point to a vector with length at least
the number of frequencies in the \fBvnadata_t\fP structure.
These functions are useful for translating between the matrix of vectors
form used for VNA measurements, and the vector of matrices form used
internally by vnadata.
.PP
The \fBvnadata_get_z0\fP() and \fBvnadata_set_z0\fP() functions
get and set the system impedance for the given \fIport\fP.
The \fBvnadata_get_z0_vector\fP() and \fBvnadata_set_z0_vector\fP()
functions get and set the complete system impedance vector, where
the length of \fIz0_vector\fP must be the maximum of \fIrows\fP and
\fIcolumns\fP.
The \fBvnadata_set_all_z0\fP() function sets the system impedances of
all ports to \fIz0\fP.
.PP
If not set, all system impedances default to 50 ohms.
Note that if frequency-dependent frequency impedances are in-use (see
below), \fBvnadata_get_z0\fP() sets \fIerrno\fP to \s-2EINVAL\s+2
and returns \s-2HUGE_VAL\s+2 and \fBvnadata_get_z0_vector\fP() sets
\fIerrno\fP to \s-2EINVAL\s+2 and returns \s-2NULL\s+2, thus these
functions are useful to test if frequency-dependent system impedances
are in-use.
Calling \fBvnadata_set_z0\fP(), \fBvnadata_set_z0_vector\fP(), or
\fBvnadata_set_all_z0\fP() when frequency-dependent frequency impedances
are in-use discards all frequency-dependent z0 values and returns to
ordinary system impedances with all unset values initialized to 50 ohms.
.PP
The \fBvnadata_get_fz0\fP() and \fBvnadata_set_fz0\fP() functions
get and set the system impedance for the given port on a per-frequency
basis.
The \fBvnadata_get_fz0_vector\fP() and \fBvnadata_set_fz0_vector\fP()
functions get and set the complete system impedance vector for the
given frequency index, where the length of \fIz0_vector\fP must be the
maximum of \fIrows\fP and \fIcolumns\fP.
The \fBvnadata_get_fz0\fP() and \fBvnadata_get_fz0_vector\fP() functions
work both when frequency-dependent system impedances are in-effect and
when they're not; in the later case, they ignore the \fIfindex\fP argument.
The \fBvnadata_set_fz0\fP() and \fBvnadata_set_fz0_vector\fP() functions
establish frequency-dependent system impedances, preserving the ordinary
system impedances for all other entries.
.PP
The \fBvnadata_convert\fP() function converts from one parameter type
to another, writing the result into \fIvdp_out\fP.
If \fIvdp_out\fP refers to the same structure as \fIvdp_in\fP, then an
in-place conversion is done.
If \fIvdp_out\fP is not the same as \fIvdp_in\fP and \fInewtype\fP
is the same type as the input matrix, the data are simply copied.
\fBvnadata_convert\fP() supports all 56 parameter conversions plus 8
conversions from parameter data to input impedance vector, a row vector
representing the impedances looking into each port of the network when
all other ports are terminated in the given system impedances.
.\"
.SH "RETURN VALUE"
On success, the get functions return the requested value and set functions
return zero.
On error, the integer valued functions return -1; the pointer valued
functions return NULL, and the double and double complex functions return
HUGE_VAL.
.SH EXAMPLES
.nf
.ft CW
#include <complex.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <vnadata.h>

#define PI      3.14159265
#define FMIN    100e+3          /* Hz */
#define FMAX    1e+9            /* Hz */
#define N       9               /* number of frequencies */
#define L       796e-9          /* Henries */
#define C       318e-12         /* Farads */

int main(int argc, char **argv)
{
    vnadata_t *vdp;
    const double fstep = log(FMAX / FMIN) / (double)(N - 1);

    /*
     * Set up Z-parameter matrix for an L-C divider.
     */
    if ((vdp = vnadata_alloc_and_init(N, 2, 2, VPT_Z)) == NULL) {
        (void)fprintf(stderr, "%s: vnadata_alloc_and_init: %s\\n",
                argv[0], strerror(errno));
        exit(1);
    }
    for (int findex = 0; findex < N; ++findex) {
        double f = FMIN * exp((double)findex * fstep);
        double complex s = 2 * PI * I * f;
        double complex z[2][2];

        if (vnadata_set_frequency(vdp, findex, f) == -1) {
            (void)fprintf(stderr, "%s: vnadata_set_frequency: %s\\n",
                    argv[0], strerror(errno));
            exit(2);
        }
        z[0][0] = 1.0 / (C * s) + L * s;
        z[0][1] = 1.0 / (C * s);
        z[1][0] = z[0][1];
        z[1][1] = z[0][1];
        if (vnadata_set_matrix(vdp, findex, &z[0][0]) == -1) {
            (void)fprintf(stderr, "%s: vnadata_set_matrix: %s\\n",
                    argv[0], strerror(errno));
            exit(3);
        }
    }

    /*
     * Convert to S-parameters and print.
     */
    if (vnadata_convert(vdp, vdp, VPT_S) == -1) {
        (void)fprintf(stderr, "%s: vnadata_convert: %s\\n",
                argv[0], strerror(errno));
        exit(4);
    }
    (void)printf("s-parameters (dB-degrees)\\n");
    (void)printf("-------------------------\\n");
    for (int findex = 0; findex < N; ++findex) {
        double f = vnadata_get_frequency(vdp, findex);

        (void)printf("f %7.2f MHz\\n", f / 1.0e+6);
        for (int row = 0; row < 2; ++row) {
            for (int column = 0; column < 2; ++column) {
                double complex value;

                value = vnadata_get_cell(vdp, findex, row, column);
                (void)printf("  %5.1f %6.1f%s",
                        20 * log10(cabs(value)), 180 / PI * carg(value),
                        column < 1 ? "," : "");
            }
            (void)printf("\\n");
        }
        (void)printf("\\n");
    }
    (void)printf("\\n");

    /*
     * Convert to impedance into each port.
     */
    if (vnadata_convert(vdp, vdp, VPT_ZIN) == -1) {
        (void)fprintf(stderr, "%s: vnadata_convert: %s\\n",
                argv[0], strerror(errno));
        exit(5);
    }
    (void)printf("input-impedances (ohms-degrees)\\n");
    (void)printf("------------------------------\\n");
    for (int findex = 0; findex < N; ++findex) {
        double f = vnadata_get_frequency(vdp, findex);

        (void)printf("f %7.2f MHz\\n", f / 1.0e+6);
        for (int port = 0; port < 2; ++port) {
            double complex value;

            value = vnadata_get_cell(vdp, findex, 0, port);
            (void)printf("  %9.3e %6.1f%s",
                    cabs(value), 180 / PI * carg(value),
                    port < 1 ? "," : "");
        }
        (void)printf("\\n");
    }
    (void)printf("\\n");
    exit(0);
}
.ft R
.fi
.\"
.SH "SEE ALSO"
.BR vnacal "(3), " vnaconv "(3), " vnafile "(3)"
