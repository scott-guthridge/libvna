/*
 * Vector Network Analyzer Library
 * Copyright Â© 2020-2023 D Scott Guthridge <scott_guthridge@rompromity.net>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * Test that the V matrices correctly convert the residuals of the
 * equations of a measured standard to errors in each associated
 * measurement.
 *
 * Strategy:
 *   Add a series of random standards to vnacal_new with errors added into
 *   the measurements.  Use more standards than needed so that that the
 *   linear system is overdetermined and the equations produce residuals.
 *   Set up the environment for vnacal_new_solve, but don't actually
 *   solve.  Instead, use the known error terms generated by the test to
 *   update the V matrices.  Compute the residuals of each equation and
 *   check that they're equal to the measurement errors we added above.
 */

#include "archdep.h"

#include <assert.h>
#include <complex.h>
#include <math.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <stdio.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include "vnacal_internal.h"
#include "libt.h"
#include "libt_crand.h"
#include "libt_vnacal.h"


#define NTRIALS		40
#define FREQUENCIES	2

/*
 * Command Line Options
 */
char *progname;
static const char options[] = "av";
static const char *const usage[] = {
    "[-av]",
    NULL
};
static const char *const help[] = {
    "-a	 abort on data miscompare",
    "-v	 show verbose output",
    NULL
};
bool opt_a = false;
int  opt_v = 0;

/*
 * error_fn: error reporting function
 *   @message: error message
 *   @arg: (unused)
 *   @category: error category (unused)
 */
static void error_fn(const char *message, void *arg, vnaerr_category_t category)
{
    (void)printf("%s: %s\n", progname, message);
}

/*
 * run_vnacal_v_matrices_trial: calibrate with random multi-port standards
 *   @trial: test trial
 *   @type: error term type
 *   @m_rows: number of VNA ports that detect signal
 *   @m_columns: number of VNA ports that generate signal
 *   @frequencies: number of test frequenciens
 */
static libt_result_t run_vnacal_v_matrices_trial(int trial,
	vnacal_type_t type, int m_rows, int m_columns,
	int frequencies)
{
    const int ports = MAX(m_rows, m_columns);
    const int diagonals = MIN(m_rows, m_columns);
    bool add_all_match;
    int random_standards;
    int standards;
    int standard;
    int equation = 0;
    int equations = 0;
    int x_length;
    vnacal_t *vcp = NULL;
    libt_vnacal_terms_t *ttp = NULL;
    const vnacal_layout_t *vlp = NULL;
    vnacal_new_t *vnp = NULL;
    libt_vnacal_measurements_t *tmp = NULL;
    double complex ***m_errors = NULL;		/* [standard][m_cell][findex] */
    vnacal_new_solve_state_t vnss;
    const double sigma_fl = 1.0;
    double complex **x_vector = NULL;		/* [findex][xindex] */
    libt_result_t result = T_FAIL;

    /*
     * Calculate the number of standards needed.  Add one to make sure
     * the system is overdetermined.
     */
    random_standards = libt_vnacal_calc_needed_standards(type,
	    m_rows, m_columns, &add_all_match) + 1;

    /*
     * If -v, print the test header.
     */
    if (opt_v != 0) {
	(void)printf("Test vnacal_test_v_matrices: trial %3d size %d x %d "
		"type %-4s %2d random standards%s\n",
		trial, m_rows, m_columns, vnacal_type_to_name(type),
		random_standards, add_all_match ? "+match" : "");
    }

    /*
     * Avoid trouble in vs_free if we fail before init.
     */
    (void)memset((void *)&vnss, 0, sizeof(vnss));

    /*
     * Create the calibration structure.
     */
    if ((vcp = vnacal_create(error_fn, NULL)) == NULL) {
	(void)fprintf(stderr, "%s: vnacal_create: %s\n",
		progname, strerror(errno));
	goto out;
    }

    /*
     * Generate random error parameters.
     */
    if ((ttp = libt_vnacal_generate_error_terms(vcp, type, m_rows, m_columns,
		    frequencies, NULL, 0)) == NULL) {
	(void)fprintf(stderr, "%s: libt_vnacal_generate_error_terms: %s\n",
		progname, strerror(errno));
	goto out;
    }
    vnp = ttp->tt_vnp;
    vlp = &ttp->tt_layout;
    x_length = vnp->vn_systems * (vlp->vl_t_terms - 1);

    /*
     * Set the measurement error.  The value isn't used by anything --
     * we do this only to enable V matrix generation.
     */
    if (vnacal_new_set_m_error(vnp, /*frequency_vector*/NULL,
		/*frequencies*/1, &sigma_fl, /*sigma_tr*/NULL) == -1) {
	goto out;
    }

    /*
     * Create random errors for each measurement.
     */
    standards = random_standards;
    equations = random_standards * m_rows * m_columns;
    if (add_all_match) {
	standards += 1;			/* include all-match */
	equations += diagonals;		/* diagonal elements only */
    }
    if ((m_errors = calloc(standards, sizeof(double complex **))) == NULL) {
	(void)fprintf(stderr, "%s: calloc: %s\n", progname, strerror(errno));
	goto out;
    }
    for (standard = 0; standard < standards; ++standard) {
	if ((m_errors[standard] = calloc(m_rows * m_columns,
			sizeof(double complex *))) == NULL) {
	    (void)fprintf(stderr, "%s: calloc: %s\n",
		    progname, strerror(errno));
	    goto out;
	}
	for (int m_row = 0; m_row < m_rows; ++m_row) {
	    for (int m_column = 0; m_column < m_columns; ++m_column) {
		int m_cell = m_row * m_columns + m_column;

		if (add_all_match && standard == 0 && m_row != m_column) {
		    continue;
		}
		if ((m_errors[standard][m_cell] = calloc(frequencies,
				sizeof(double complex))) == NULL) {
		    (void)fprintf(stderr, "%s: calloc: %s\n",
			    progname, strerror(errno));
		    goto out;
		}
		for (int findex = 0; findex < frequencies; ++findex) {
		    m_errors[standard][m_cell][findex] = libt_crandn();
		}
	    }
	}
    }
    if (opt_v > 1) {
	(void)printf("m_errors:\n");
	for (int findex = 0; findex < frequencies; ++findex) {
	    (void)printf("findex %d\n", findex);
	    for (standard = 0; standard < standards; ++standard) {
		(void)printf("  standard %d\n", standard);
		for (int m_row = 0; m_row < m_rows; ++m_row) {
		    (void)printf("   ");
		    for (int m_column = 0; m_column < m_columns; ++m_column) {
			int m_cell = m_row * m_columns + m_column;

			if (m_errors[standard][m_cell] != NULL) {
			    (void)printf(" %+f%+fj",
				    creal(m_errors[standard][m_cell][findex]),
				    cimag(m_errors[standard][m_cell][findex]));
			} else {
			    (void)printf(" %+f%+fj", 0.0, 0.0);
			}
		    }
		    (void)printf("\n");
		}
	    }
	}
	(void)printf("\n");
    }

    /*
     * Allocate the measurement matrices.
     */
    if ((tmp = libt_vnacal_alloc_measurements(type, m_rows, m_columns,
		    frequencies, /*ab*/false)) == NULL) {
	goto out;
    }

    /*
     * If needed, add an all match matrix.
     */
    standard = 0;
    if (add_all_match) {
	int s[ports * ports];

	for (int i = 0; i < ports * ports; ++i) {
	    s[i] = VNACAL_MATCH;
	}
	if (libt_vnacal_calculate_measurements(ttp, tmp, s, ports, ports,
		    NULL) == -1) {
	    goto out;
	}
	for (int diagonal = 0; diagonal < diagonals; ++diagonal) {
	    for (int findex = 0; findex < frequencies; ++findex) {
		const int m_cell = diagonal * m_columns + diagonal;

		assert(equation < equations);
		tmp->tm_b_matrix[m_cell][findex] +=
		    m_errors[standard][m_cell][findex];
	    }
	    ++equation;
	}
	if (vnacal_new_add_mapped_matrix_m(vnp, tmp->tm_b_matrix,
		    m_rows, m_columns, s, ports, ports, NULL) == -1) {

	    goto out;
	}
	++standard;
    }

    /*
     * Add random standards.
     */
    for (int rs = 0; rs < random_standards; ++rs) {
	int s[ports * ports];

	if (libt_vnacal_generate_random_parameters(vcp, s,
		    ports * ports) == -1) {
	    goto out;
	}
	if (libt_vnacal_calculate_measurements(ttp, tmp, s,
		    ports, ports, NULL) == -1) {
	    goto out;
	}
	for (int row = 0; row < m_rows; ++row) {
	    for (int column = 0; column < m_columns; ++column) {
		const int m_cell = row * m_columns + column;

		for (int findex = 0; findex < frequencies; ++findex) {

		    assert(equation < equations);
		    tmp->tm_b_matrix[m_cell][findex] +=
			m_errors[standard][m_cell][findex];
		}
		++equation;
	    }
	}
	if (vnacal_new_add_mapped_matrix_m(vnp,
		    tmp->tm_b_matrix, m_rows, m_columns,
		    s, ports, ports, NULL) == -1) {

	    goto out;
	}
	for (int i = 0; i < ports * ports; ++i) {
	    if (vnacal_delete_parameter(vcp, s[i]) == -1) {
		goto out;
	    }
	}
	++standard;
    }
    libt_vnacal_free_measurements(tmp);
    tmp = NULL;
    assert(standard == standards);
    assert(equation == equations);

    /*
     * Init the solve state structure.
     */
    if (vs_init(&vnss, vnp) == -1) {
	goto out;
    }

    /*
     * Build error term vectors with the unity term removed.
     */
    if ((x_vector = calloc(frequencies, sizeof(double complex *))) == NULL) {
	(void)fprintf(stderr, "%s: calloc: %s\n", progname, strerror(errno));
	goto out;
    }
    for (int findex = 0; findex < frequencies; ++findex) {
	int xindex = 0;

	if ((x_vector[findex] = calloc(x_length,
			sizeof(double complex))) == NULL) {
	    (void)fprintf(stderr, "%s: calloc: %s\n",
		    progname, strerror(errno));
	    goto out;
	}
	for (int sindex = 0; sindex < vnp->vn_systems; ++sindex) {
	    const int src_offset = sindex * vlp->vl_t_terms;
	    const int unity_index = _vl_unity_offset(vlp, sindex);

	    for (int term = 0; term < vlp->vl_t_terms; ++term) {
		int src_index = src_offset + term;

		if (term != unity_index) {
		    x_vector[findex][xindex++] =
			ttp->tt_error_term_vector[findex][src_index];
		}
	    }
	}
    }

    /*
     * Calculate the residuals and test that each is equal to the
     * respective measurement error.
     */
    if (opt_v >= 2) {
	(void)printf("check:\n");
    }
    for (int findex = 0; findex < frequencies; ++findex) {
	equation = 0;
	if (vs_start_frequency(&vnss, findex) == -1) {
	    goto out;
	}
	if (vs_update_all_v_matrices(__func__, &vnss,
		    x_vector[findex], x_length) == -1) {
	    goto out;
	}
	for (int sindex = 0; sindex < vnp->vn_systems; ++sindex) {
	    const int offset = sindex * (vlp->vl_t_terms - 1);

	    vs_start_system(&vnss, sindex);
	    while (vs_next_equation(&vnss)) {
		vnacal_new_equation_t *vnep = vnss.vnss_vnep;
		vnacal_new_measurement_t *vnmp = vnep->vne_vnmp;
		int m_cell = vnep->vne_row * m_columns + vnep->vne_column;
		double complex residual = 0.0;

		standard = vnmp->vnm_index;
		assert(equation < equations);
		while (vs_next_term(&vnss)) {
		    double complex value = vs_get_negative(&vnss) ? -1.0 : 1.0;
		    int xindex = vs_get_xindex(&vnss);

		    if (vs_have_m(&vnss)) {
			value *= vs_get_m(&vnss);
		    }
		    if (vs_have_s(&vnss)) {
			value *= vs_get_s(&vnss);
		    }
		    if (vs_have_v(&vnss)) {
			value *= vs_get_v(&vnss);
		    }
		    if (xindex >= 0) {
			assert(offset + xindex < x_length);
			value *= x_vector[findex][offset + xindex];
		    } else {
			value = -value;
		    }
		    residual += value;
		}
		if (opt_v >= 2) {
		    (void)printf("  actual   %+f%+fj\n",
			    creal(residual), cimag(residual));
		    (void)printf("  expected %+f%+fj\n\n",
			    creal(m_errors[standard][m_cell][findex]),
			    cimag(m_errors[standard][m_cell][findex]));
		}
		if (!libt_isequal(residual,
			    m_errors[standard][m_cell][findex])) {
		    goto out;
		}
		++equation;
	    }
	}
    }
    assert(equation == equations);
    result = T_PASS;

out:
    vs_free(&vnss);
    if (x_vector != NULL) {
	for (int findex = frequencies - 1; findex >= 0; --findex) {
	    free((void *)x_vector[findex]);
	}
	free((void *)x_vector);
    }
    if (m_errors != NULL) {
	for (int standard = standards - 1; standard >= 0; --standard) {
	    if (m_errors[standard] != NULL) {
		const int m_cells = m_rows * m_columns;

		for (int m_cell = m_cells - 1; m_cell >= 0; --m_cell) {
		    free((void *)m_errors[standard][m_cell]);
		}
		free((void *)m_errors[standard]);
	    }
	}
	free((void *)m_errors);
    }
    libt_vnacal_free_error_terms(ttp);
    vnacal_free(vcp);
    return result;
}

/*
 * test_vnacal_v_matrices: test that V matrices convert residuals to M errors
 */
static libt_result_t test_vnacal_v_matrices()
{
    static const int sizes[] = { 1, 2, 3, 4 };
    static const vnacal_type_t types[] = {
	VNACAL_T8, VNACAL_U8, VNACAL_T16, VNACAL_U16, VNACAL_UE14
    };
    libt_result_t result = T_FAIL;

    for (int trial = 1; trial <= NTRIALS; ++trial) {
	for (int si = 0; si < sizeof(sizes) / sizeof(int); ++si) {
	    for (int sj = 0; sj < sizeof(sizes) / sizeof(int); ++sj) {
		int rows = sizes[si];
		int columns = sizes[sj];

		for (int ti = 0; ti < sizeof(types) / sizeof(types[0]); ++ti) {
		    vnacal_type_t type = types[ti];

		    if (VNACAL_IS_T(type)) {
			if (rows > columns) {
			    continue;
			}
		    } else {
			if (rows < columns) {
			    continue;
			}
		    }
		    result = run_vnacal_v_matrices_trial(trial, type,
			    rows, columns, FREQUENCIES);
		    if (result != T_PASS)
			goto out;
		}
	    }
	}
    }
    result = T_PASS;

out:
    libt_report(result);
    return result;
}

/*
 * print_usage: print a usage message and exit
 */
static void print_usage()
{
    const char *const *cpp;

    for (cpp = usage; *cpp != NULL; ++cpp) {
	(void)fprintf(stderr, "%s: usage %s\n", progname, *cpp);
    }
    for (cpp = help; *cpp != NULL; ++cpp) {
	(void)fprintf(stderr, "%s\n", *cpp);
    }
    exit(99);
}

/*
 * main
 */
int
main(int argc, char **argv)
{
    /*
     * Parse Options
     */
    if ((char *)NULL == (progname = strrchr(argv[0], '/'))) {
	progname = argv[0];
    } else {
	++progname;
    }
    for (;;) {
	switch (getopt(argc, argv, options)) {
	case -1:
	    break;

	case 'a':
	    opt_a = true;
	    continue;

	case 'v':
	    ++opt_v;
	    continue;

	default:
	    print_usage();
	}
	break;
    }
    libt_isequal_init();
    exit(test_vnacal_v_matrices());
}
