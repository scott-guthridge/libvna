- Rework the matrix representation in vnacal_new to implement equation
  weighting using the more elegant method in the Van hamme paper.

- Document vnacal_new_set_m_error.  First do a little more evaluation
  on how well weighting is working.

- Add functions to set the error threshold and to retrieve errors.
    int vnacal_new_get_error_vector(vnp, double *)
    int vnacal_new_set_error_limit(vnp, double limit) - scalar

  Normalize the errors to 1 standard deviation?

- Audit the API for whether frequencies or frequency_vector comes first.
  In general, the pointer should come frist, but
  in vnacal_make_correlated_parameter, the length applies to two vectors.
  Check all and evaluate.

- Disallow rectangular S parameter matrices.

- Add a special-case solver in vnacal_new_solve for TRL when no redundant
  measurements and no measurement error is given.  Evaluate if it increases
  accuracy over the iterative approach.

- Add debian package support

- Add vnacal-T16-example.c using T-MM-SS-SM-MS standards.
  Approach: generally follow the example of vnacal-TSD-example, but
  in the simulated VNA, use the M = (Ts S + Ti) (Tx S + Tm)^-1 matrix
  equation to generate the measured value, taking into account all four
  T error matrices.  Note that test-vnacal-Silvonen16 also tests this
  case and can serve as a starting point.

- Add example for TXYZ / LXYZ
    through, 3 known reflects

- Add example for LRRM
    known line, 2 unknown equal reflects, match

- Add example for UXYZ
    unknown line with S12=S21
    3 known reflects

- Make tests that invoke each of the examples.  Create expected output
  files and compare that values are approximately equal.  Be careful
  with build and source directories set to different places.

- Add U-parameter (inverse T) support to vnaconv, vnadata and vnafile ?
  Inverse T,U parameters seem like a natural parallel to A,B, and we
  use U parameters in vnacal_new.  There is also the practial case when
  S21 = 0 but S12 != 0: we can't convert from S to T in this case, but
  we can convert to U.  But U parameters don't seem to really exist in
  practice today.  There is an alternate representation of T parameters,
  where the two rows are swapped, but they're essentially still T.
  At minimum, reserve a type slot for U.

- Bring back vnacal_apply_t from the git history (consider renaming to
  vnacal_map_t to better match what it does and avoid confusion with the
  vnacal_apply functions).  But first, explore if we can make it work
  with other than perfect match standards on the unconnected DUT ports.
  Note that even if we know these standards exactly, if the reflections
  aren't exactly zero, the system can't be solved with a linear system
  of equations because it involes products of s-parameters.  Ideally,
  we'd want to also be able to use unknown parameters and have the
  library solve for the unknowns.

  From an interface perspective, a clean approach would be to let
  positive numbers in the DUT->VNA port map to be VNA port numbers and
  zero or negative numbers represent parameters, using the negative of
  the parameter handle.

- Before the 1.0 release, change "VNACAL" to "VNACal" in the vnacal save
  file and reset the version number to 1.0.  Make vnacal_load 
  recognize capital VNACAL versions for compatibility, mapping
  old 2.0 to new 0.2 and old 3.0 to new 1.0.
