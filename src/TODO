== Measurement Tolerance & Error ==

    - Add a special-case solver in vnacal_new_solve for TRL analytically
      when no redundant measurements and no measurement error is given.
      This should greatly improve the accuracy over the numeric solution.

    - Rework the matrix representation in vnacal_new to implement
      equation weighting as described in "Flexible Vector Network
      Analyzer Calibration With Accuracy Bounds Using an 8-Term or a
      16-Term Error Correction Model", Van hamme, Bossche.  Current
      method doesn't implement it correctly.  Hopefully, this change
      will improve the numeric solution.

    - Evaluate how well weighting is working.  If it's effective, document
      vnacal_new_set_m_error; otherwise, either fix it or remove it.

    - Add functions to set the error threshold and to retrieve errors,
      if we get a good result from vnacal_new_set_m_error.
	int vnacal_new_get_error_vector(vnp, double *)
	int vnacal_new_set_error_limit(vnp, double limit) - scalar

      Decide if we should normalize errors to 1 standard deviation.


== Improvements to the Examples ==

    - Add vnacal-T16-example.c using T-MM-SS-SM-MS standards.
      Approach: generally follow the example of vnacal-TSD-example, but
      in the simulated VNA, use the M = (Ts S + Ti) (Tx S + Tm)^-1 matrix
      equation to generate the measured value, taking into account all four
      T error matrices.  Note that test-vnacal-Silvonen16 already tests this
      case and can serve as a starting point.

    - Add example for TXYZ / LXYZ
	through, 3 known reflects

    - Add example for LRRM
	known line, 2 unknown equal reflects, match

    - Add example for UXYZ
	unknown line with S12=S21
	3 known reflects


== Improvements to the Tests ==

- Make tests that invoke each of the examples.  Create expected output
  files and compare that values are approximately equal.  Be careful
  with build and source directories set to different places.


== Potential New Functionality ==

    - Remove the underscore prefix from the _vnacommon* functions, move
      vnacommon_internal.h to vnacommon.h, add man page and make them part
      of the public API.  Remove the const int [ijk]'s from the interface
      as they will likely confuse people.

    - Add frequency-dependent Z0 support to vnacal_new, vnacal.
      Complex reference impedances make sense really only if they're
      frequency dependent.

    - Bring back vnacal_apply_t from the git history (consider renaming
      to vnacal_map_t to better match what it does and avoid confusion
      with the vnacal_apply functions).  The purpose of this function
      is to permit using a VNA with fewer ports than the DUT, and
      making several measurements with different combinations of the DUT
      connected to the VNA ports to determine the S parameters of the DUT.
      When the other DUT ports are terminated in perfect match standards,
      it's relatively simple -- it essentially amounts to just piecing
      together the partial S parameters generated from each measurement.
      A more interesting case, however is where the other DUT ports
      are terminated in standards that are not quite perfect, either
      known or unknown.  Note that even if these imperfect standards
      are completely known, the S parameters can no longer be solved
      as a linear system as the system contains products of the unknown
      DUT S parameters.  In principle, though, it should be possible to
      solve the system numerically if we're given enough measurements.

      For each measurement, to describe what each DUT port is connected
      to, we can use a port map with one entry per DUT port.  When the
      port is connected to a standard, we can use one of the constant
      VNACAL_MATCH, VNACAL_SHORT, etc. values or a value returned from
      one of the vnacal_make_*_parameter functions.  These values are
      never negative.  When a DUT port is connected to the VNA, we can
      use the negative of the VNA port number.

   - Figure out what it will take to support differential input ports.

